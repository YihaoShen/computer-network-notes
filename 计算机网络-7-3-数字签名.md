## 数字签名
数字签名必须保证能够实现以下3点：
* 接收者能够核实发送者对报文的签名。也就是所，接收者能够确认该报文的确是发送者发送的。其他人无法伪造对报文的签名。这叫**报文鉴别**。
* 接收者确信所收到的数据和发送者发送的数据完全一样，没有被篡改过。这叫**报文的完整性**。
* 发送者事后不能抵赖对报文的签名，这叫**不可否认**。

现在已有多种实现数字签名的方法。但采用公钥算法要比对称密钥算法更容易实现。下面就来介绍这种数字签名。
为了进行**签名**，A用其私钥$SK_A$对报文X进行D运算(如图7-4)，D运算本来叫做解密运算，可是，还没有加密怎么就进行解密呢？这并没有关系。因为D运算只是得到了某种不可读的密文。在图7-4中我们写成”D运算“而不是解密运算，就是为了避免产生这种误解。A把经过D运算得到的密文传给B。B为了**核实签名**，用A的公钥进行E运算，还原出明文X。请注意，任何人使用A的公钥$PK_A$进行E运算后都可以得出A发送的明文。可见图7-4所示的通信并非为了保密，而是为了进行签名和核实签名，即确认此明文是A发送的。

![image](https://img2020.cnblogs.com/blog/2361214/202109/2361214-20210916115637873-1724547400.png)

数字签名为什么具有上述的上述的三个功能点？
* 因为除了A之外没人持有A的私钥$SK_A$。所以除了A外没有别人能产生密文$D_{SK_A}(X)$。这样，B就相信报文X就是A签名发送的，这就是报文鉴别的原理。
* 同理，其他人如果篡改过报文，但由于无法得到A的私钥$SK_A$来对X进行加密，那么B对篡改过的报文进行解密后，将会得出不可读的明文，就知道收到的报文被篡改过。这样就可以保证报文的完整性。
* 若A要抵赖曾经发送报文给B，B可以把X以及$DSK_A(X)$出示给进行公证的第三者，第三者很容易的用$PK_A$去证实A确实发送X给B，这就是不可否认的功能。**这三项的关键都是没有其他人能够持有A的私钥SKA**。

但上述的过程仅仅只是对报文进行了签名，对报文X还未保密，因为截获到密文$D_{SXK_A}(X)$并知道发送者身份的任何人，通过查阅手册即可获得发送者的公钥$PK_A$，因而能知道报文的内容，若采用图7-5所示的方法，则可以同时实现秘密通信和数字签名。图中$SK_A$和$SK_B$分别为A和B的私钥，$PK_A$和$PK_B$分别为A和B的公钥。

![image](https://img2020.cnblogs.com/blog/2361214/202109/2361214-20210916115650697-1539814278.png)

A向B发送时：A使用A的私钥$SK_A$对报文X进行签名，然后使用B的公钥$PK_B$对报文X进行加密。
B接收到后使用B的私钥$SK_B$对报文X进行解密,同时使用A的公钥$PK_A$对签名进行验证。