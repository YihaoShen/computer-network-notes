##  IP层转发分组的流程

![image](https://img2020.cnblogs.com/blog/2361214/202108/2361214-20210811163506663-201355922.png)

上图是一个路由器怎么进行分组转发的例子：有四个A类网络通过三个路由器连接在一起，每一个网络上都可能会有成千上万台主机。若路由表指出每一台主机该进行怎样的转发。则要维护的路由表是非常的庞大。**如果路由表指定到某一个网络如何转发，则路由表中只有4行，每一行对应一个网络。**以路由器2的路由表为例：由于R2同时连接在网络2和网络3上，因此只要目标主机在网络2或者网络3上，都可以通过接口0或者1或者路由器R2直接交付（当然还有使用ARP协议找到这些主机相应的MAC地址）。若目标主机在网络1中，则下一跳路由器为R1，其IP地址为20.0.0.7。路由器R2和R1由于同时连接在网络2上，因此从路由器2把转发分组給R1是很容易的。**我们应当注意到：每一个路由器至少都要拥有两个不同的IP地址。**总之，在路由表中，对每一条路由最主要的是以下两条信息：**（目的网络，下一跳地址）**我们根据目的网络地址来确定下一跳路由器，这样可以得到以下结论：

* IP数据包最终一定可以找到目的主机所在目的网络上的路由器（可能会经过多次间接交付）。

* 只有到达最后一个路由器时，才试图向目的主机进行间接交付。

虽然互联网上所有的分组转发都是**基于目的主机所在的网络**，但是在大多数情况下都允许这样的实例：**对特定的主机指明一个路由**，这种路由叫**特定主机路由**。采用特定主机路由可以使网络人员方便管理控制网络和测试网络

路由器还可以采用**默认路由**以减少路由表所占用的空间和搜索路由表所使用的时间。

当路由器接收到一个待转发的数据报，在从路由表中得出下一跳路由器的IP地址后，不是把这个地址写入IP数据报，而是送交**数据链路层的网络接口软件**，网络接口软件把负责下一跳的路由器IP地址转化为硬件地址（必须使用ARP），将硬件地址写入MAC帧的首部，然后根据这个硬件地址找到下一跳路由器。由此可见，当发送一连串的数据报时，上述的这种查找路由表，用ARP得到硬件地址，把硬件地址写入MAC地址首部等过程，将不断地重复进行，造成了一定的开销。

根据以上几点，我们提出**分组转发算法：**

1. 从数据报的首部提取目的主机IP地址D，得出目的网络地址N。
2. 若N就是与此路由器直接相连的某个网络地址，则进行**直接交付**，不需要再经过其他的路由器。直接把数据报交付给目的主机（这里包括把目的主机D转化为MAC地址，把数据报封装成MAC帧，再发送该帧）；否则就是间接交付，执行3。
3. 若路由表有目的地址为D的特定主机路由，则把数据报传给路由表中所指明的下一跳路由器。否则进行4。
4. 若路由表中有到达网络N的路由，则把数据报传给路由表中所指明的下一跳路由地址；否则，执行5。
5. 若路由表中有一个默认路由，则把数据报传递给路由表中所指明的默认路由。否则，执行6。
6. 报告转发分组出错。

这里我们需要强调一下，路由表并没有给分组指明某个网络的完整路径(即先经过哪一个路由器，然后再经过哪一个路由器，等等)。路由表指出，到达某个网络应该先到达某个路由器(下一条路由器)，在到达下一跳路由器之后，再继续查找路由表，知道再下一步应当到达哪一个路由器。这样一步步的查找下去，直到最后到达目的网络。

## 构建子网和划分超网
### 划分子网
#### 从二级IP地址到三级IP地址
为什么划分子网？
1. IP地址空间利用率有时候很低：每一个A类地址可连接的主机数超过1000万，每一个B类地址可连接的主机数也超过6万个。
2. 给每一个物理网络分配的网络号会使得**路由表变得太大**导致网络性能变差。
3. **两级IP地址不够灵活**。

为解决上述问题，从1985年引出**子网络号字段**，使得两级IP地址变为三级IP地址，这种做法叫做**划分子网(subnetting)【RFC950】**。

划分子网的基本思路：

1. 一个拥有许多物理网络的单位，可将所属的物理网络划分为若干个 **子网**。划分子网属于单位内部的事情。本单位以外的网络**看不见**这个网络是由多少个子网组成，因此这个单位对外仍然表现一个网络。
2. 划分子网的方法是从网络的主机号借用若干位当做子网络号(subnet-id)，当然主机号也就减少了同样的位数，于是二级IP地址就变成了三级IP地址：网络号，子网络号，主机号。
3. 凡是从其他网络发送给本单位某一台主机的IP数据报，仍然是根据IP数据报的目的网络号找到连接在本单位的路由器，但是此路由器在收到IP数据报之后，再按照网络号和子网络号找到目的子网，把IP数据报交付给目标主机。

划分子网的用例

![image](https://img2020.cnblogs.com/blog/2361214/202108/2361214-20210811163536182-956795984.png)

如上图为某单位拥有一个B类IP地址，网络地址为145.13.0.0（网络号为145.13），凡是目的网络为145.13.x.x的数据报都会送到这个网络上路由器R1上。

现在把该网络划分为三个字网，这里假设子网络号占用8位，因此主机号就只剩下16-8=8位了，所划分的三个字网为145.13.3.0,145.13.7.0,145.3.21.0。路由器在接受到145.13.0.0上的路由器数据后，再根据数据报的目的地址把它转化到相应的子网。

总之，当没有划分子网的时候，IP地址是两节结构。划分子网后IP地址就变成了三级结构。划分子网只是把IP地址的主机号这部分进行再划分，而不改变IP地址原来的网络号。

#### 子网掩码

假定有一个IP数据报（其目的地址为145.13.3.10）已经到达了路由器R1，那么这个路由器如何把它转发到子网145.13.3.0呢？
我们知道，从IP数据包报的首部无法看出源主机的目的主机所连接的网络是否进行了子网划分。这是因为32位IP地址本身以及数据报的首部没有包含任何关于子网划分的信息。因此必须另想办法，这就是使用**子网掩码**。

![image](https://img2020.cnblogs.com/blog/2361214/202108/2361214-20210811163557136-1529382238.png)

把三级IP地址的子网掩码和收到的目的地址的IP地址**逐位进行与（AND）运算，就可以立即得到网络地址，剩下的步骤就交给路由器处理分组。**

使用子网掩码的好处是：不管网络有没有划分子网，只要把子网掩码和IP地址进行逐位**与(AND)**运算,就立即得出网络地址来，这样在路由器处理到来的分组时就可采取同样的做法。

在不划分子网时，为什么还要使用子网掩码？这就是为了更便于查找路由表。现在互联网规定：所有网络都必须使用子网掩码，同时在路由器的路由表中也必须有子网掩码这一栏。如果一个网路不划分子网，那么该网络的子网掩码就是用**默认的子网掩码**，默认子网掩码中1的位置和IP地址中的网络号字段net-id正好相对应。因此，若用默认子网掩码和某个不划分子网的IP地址逐位相"与"，就应该能够得出该IP地址的网络地址来，这样做可以不用查找该地址的类别位就能够知道这是哪一类的IP地址。显然:
1. A类地址的默认子网掩码是255.0.0.0，或0xFF000000.
2. B类地址的默认子网掩码是255.255.0.0,或者是0xFFFF0000.
3. C类地址的默认子网掩码是255.255.255.0,或者是0xFFFFFF00.

图4-21是这三类IP地址的网络地址和相应的默认子网掩码:
![image](https://img2020.cnblogs.com/blog/2361214/202108/2361214-20210811163612814-1886217923.png)

**子网掩码是一个网络或者一个子网的重要属性**。在RFC950成为互联网标准后，路由器在和相邻路由器交换路由信息时，必须把自己所在的网络(或子网)的子网掩码告诉相邻路由器，在路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码。若一个路由器连接在两个子网上就拥有两个网络地址和两个子网掩码。


例4-2：
已知IP地址是141.14.72.24，子网掩码是255.255.192.0,求网络地址：
解: 255.255.192.0的二进制：11111111 11111111 11000000 00000000

IP 141.14.72.24二进制： 11111111 11111111 01001000 
00000000

将IP地址二进制与子网掩码二进制进行**与(AND)运算**为       ：:11111111 11111111 11000000 00000000
即网络IP为：141.14.64.0

### 使用子网是时分组转发

在划分子网的情况下，分组转发的算法必须作出改动。在使用子网划分后，路由表应该包含以下内容：

* 目的网络地址
* 子网掩码
* 下一跳

在划分子网的情况下，路由器转发分组的算法如下：

1. 从收到的数据包的首部提取目的IP地址D。
2. 先判断是否为直接交付。对路由器直相连的网络逐个进行排查：**用各个网络的子网掩码和D逐位相与（AND），看结果是否和对用的网络地址匹配上。若匹配，则把分组进行直接交付，转发结束**，否则就是间接交付，执行（3）。
3. 若路由表有目的地址为D的特定主机路由，则把数据报传给路由表中所指明的下一跳路由器；否则进行（4）。
4. 对路由表中每一行（目的网络地址，子网掩码，下一跳地址），用其中的子网掩码和D进行逐位相与（AND），其结果为N。若N与该行的目的网络地址匹配，则把数据报传给该行所指明的下一跳路由器；否则，执行（5）。
5. 如果有表中有一个默认路由，传送给路由表中所指明的默认路由；否则执行（6）。
6. 报告转发分组错误。

例4-4：
图4-24有三个字网，两个路由器，以及路由器R1的部分路由表。现在源主机H1向目的主机H2发送分组。试讨论R1收到H1向H2发送的分组后查路由表的过程。

![image](https://img2020.cnblogs.com/blog/2361214/202108/2361214-20210811163626843-954310906.png)

解：

源主机H1向目标主机H2发送的分组的目的地址为128.30.33.138。

源主机H1把本子网的子网掩码255.255.255.128与H2的IP地址128.30.33.128相与得到128.30.33.128，它不等于H1的网络地址（128.30.33.0）。这说明主机H2与主机H1不在同一个网段上，因此H1不能把数据包直接交付给H2。必须交给子网上的默认路由R1,由R1转发。

路由表在接受到这个分组之后，就在其路由表中逐行匹配寻找。
首先看R1路由表的第一行：用这一行的子网掩码255.255.255.128与H2IP地址进行互与，得到128.30.33.128，然后和这一行用样的方法进行第二行，结果发现相与出来的结果和目的网络地址匹配，则说明这个网络（子网2）就是收到的分组所要寻找的目的网络。于是就不用继续找了。R1把分组从接口1直接交付给主机H2(他们都在一个子网上)。

### 无分类编址CIDR（构造超网）

在一个划分子网的网络中可使用几个不同的子网掩码。使用变长**子网掩码VLSM(Variable Length Subnet Mask)**可进一步提高IP地址资源的利用率。在VLSM的基础上又进一步研究出**无分类编制**方法。它的正式名字是无分类域间路由选择CIDR(Classless Inter-Domain Routing)。

**CIDR**最主要的特点有两个：

1. **CIDR消除了传统的A类地址，B类地址，C类地址和划分子网的概念**。因此能更加有效的分配IPV4的地址空间。并且在新的IPv6使用之前容许互联网规模继续增长。CIDI把32位的IP地址分为前后两个部分。前面部分是**网络前缀(network-prefix)**，用来指明网络，后面部分则用来指明主机。因此CIDI使IP地址从三级编址又回到了两级编址，但这已是**无分类的两级编址**。其记法是:


CIDR还使用斜线记法，就是在IP地址后面加上斜线/,然后写上**网络前缀所占的位数**。例如IP地址为128.14.35.7/20是某CIDR地址快中的一个地址，其中前20位就是网络前缀，后面的14位是主机位。如图所示：

![image](https://img2020.cnblogs.com/blog/2361214/202108/2361214-20210811170947427-909980263.png)

![image](https://img2020.cnblogs.com/blog/2361214/202108/2361214-20210811171004218-1364360375.png)

当然以上地址的主机号全为0和全为1的地址，一般并不使用，这个地址块共有2^12个地址，我们可以使用地址块中最小的地址和网络前缀来指明这个地址快。例如，上述的地址块可记为128.14.32.0/20。


为了更方便的进行路由选择，CIDR使用了32位的地址掩码(address mask)。地址掩码是由一串1和一串0组成，**而1的个数就是网络前缀的个数。**虽然CIDR不使用子网了，但是出于某些原因，CIDR使用的地址掩码也可以继续称为**子网掩码，斜线记法中，斜线后面的数字就是1的个数**。例如，/20地址快的地址掩码是**11111111 11111111 11110000 00000000**(20个连续的1)。**斜线记法中，斜线后面的数字就是地址掩码中1的个数。**

斜线记法还有一个好处就是它除了可以表示一个IP地址外，还提供了一些其他重要的信息。我们举例说明如下：
例如，地址为192.199.170.82/27不仅表示IP地址是192.199.170.82，而且还表示这个地址快的网络前缀有27位(剩下的5位是主机号)，因此这个地址快包含32个IP地址($2^5$=32)。通过见到那的计算还可以得出，这个地址块的最小地址是192.199.170.64，最大地址是192.199.170.95。具体的计算方法是这样的：找到地址掩码中1和0的交界处发生在地址中的哪一个字节，现在是第四个字节，因此只要把这一个字节的十进制82用二进制表示即可：82的二进制是01010010,取其前3位(这3位加上前3字节的24位就够成了27位)，再把后面的5位都写成0，即01000000，等于十进制64，这样就找到了地址快的最小地址192.199.170.64，再把最后面5位都置为1，即01011111,等于十进制的95，这就找到了地址块中的最大地址192.199.170.95。

由于一个CICR地址块有很多地址，所以在路由表中就利用CIDR地址块来查找目的网络。这种地址的聚合常称之为**路由聚合(route aggregation)**,它使得路由表中的一个项目可以表示原来传统分类地址的很多个路由，路由聚合也称之为**构成超网(supernetting)**，路由聚合有利于减少路由器之间的路由选择信息的交换，从而提高了整个互联网的性能。

每一个CIDR地址块中的地址数一定是2的整数次幂，这就是**构建超网**的来源。

**网络前缀越短**，其地址块所包含的地址数就越多，而在三级结构的IP地址中，划分子网是使网络前缀变长。

### 最长前缀匹配
在使用了CIDR时，由于采用网络前缀这种记法，IP地址由网络前缀和主机号这两部分组成，因此在路由表中的项目也要有相应的变化，这时，每个项目由**网络前缀**和**下一跳地址组成**，**但是在查找路由表时可能会得到不止一个匹配结果**，这样就带来一个问题：我们应该从这些匹配结果中选择哪一条路由呢？

正确的答案是：**应但从匹配结果中选择具有最长网络前缀的路由**，这就做**最长前缀匹配(long-prefix matching)**，这是因为网络前缀越长，说明其地址块越小因而路由就越具体，最长前缀匹配又称之为**最长匹配**或者**最佳匹配**。

### 使用二叉线索查找路由表

使用CIDR后，由于要寻找最长前缀匹配，使路由表的查找过程变的十分复杂，当路由表的项目数很大的时候，怎样设法减少路由表的平均查找时间就成为了一个非常重要的问题，现在常用的是**二叉线索(binary trie)**,它是一种特殊结构的树，IP地址中从左到右的比特值决定了从根节点逐层向下层延伸的路径，二二叉线索中的各个路径就代表路由表中存放的各个地址。

图4-26用一个例子说明二叉树线索的结构，图中给出了5个IP地址。为了简化二叉线索的结构，可以先找出对应一与每一个IP地址的唯一前缀(unique prefix)，所谓唯一前缀就是在表中所有的IP地址中，该前缀时唯一的，这样就可以用这些唯一前缀来构造二叉线索。在进行查找时，只要能够和唯一前缀匹配相匹配就可以了。

从二叉树的根节点自顶向下的深度最多有32层，每一层对应于IP地址中的一位。



