## 地址解析协议ARP和IP数据报首部

​在实际的应用中，我们会经常遇见这样的一个问题：我们已知一个机器（主机或者路由器的）IP地址，我们怎么获取相应的硬件地址？，**地址解析协议就是用来解决这个问题的。**

ARP协议的作用：
![image](https://img2020.cnblogs.com/blog/2361214/202108/2361214-20210804213540516-962843729.png)

由上图可知：
首先ARP协议划归为**网络层**，但是ARP协议是为了从网络层使用的IP地址，解析出在数据链路层的MAC地址，因此有的书籍也会把ARP协议划分到数据链路层，这也是可以的。

ARP协议的要点

网络层使用的是IP地址，但在实际的链路层传输数据帧我们使用的是MAC地址。在一个网络上可能会有新的主机加入或者旧的主机撤去。除此之外更换网络适配器也会导致MAC地址发生变化。**ARP地址解析协议**解决这个问题的方法是在主机ARP高速缓存中存放一张**IP地址到MAC地址**的映射表，而且这个表还要**动态更新（添加或者删除）**

每个主机都有一个ARP高速缓存（**ARP cache**），里面有着**本局域网**的各个主机和路由器的IP地址到硬件地址的映射表，这些都是该主机目前知道的一些地址。那么主机该怎么知道这些地址呢？

![image](https://img2020.cnblogs.com/blog/2361214/202108/2361214-20210804213555626-541121323.png)

1. ARP进程在本局域网内广播发送一个ARP请求分组。ARP请求分组的主要内容是：我的IP是209.0.0.5,我的MAC地址为00-00-C0-15-AD-18,我想知道IP地址为209.0.0.6的MAC地址为多少？

2. 在本局域网所有的主机运行的ARP进程都会收到这条此ARP请求分组。
3. 在主机B的IP地址与ARP请求分组中要查询的IP地址一致，就收下这个ARP请求分组，并向主机主动发送一个ARP响应分组，同时在这个ARP响应分组写入自己的MAC地址。由于其他主机的IP地址和ARP请求要查询的IP地址不一样，因此都不会理会这个ARP请求分组。

![image](https://img2020.cnblogs.com/blog/2361214/202108/2361214-20210804213612741-1772336685.png)
注意：
**ARP请求分组是广播，但是ARP响应分组单播**，就从源地址发送到一个目的地址。
4. 主机A收到这个ARP响应分组后，就在自己本地的ARP缓存中写入主机B的IP地址到MAC地址的映射。同理，当主机B在接收到这个主机A发送过来的ARP请求分组时也会在主机B本地的ARP缓存中写入主机A的IP地址到MAC地址的映射。
可见。ARP高速缓存是非常的有用，如果不使用ARP高速缓存，那么任何一台主机只要进行一次通信，就必须要使用ARP协议广播ARP请求分组，只会导致网络上的通信量大大增加。ARP把已经得到的地址映射写入高速缓存中，这样该主机下次再和具有同样目的主机进行通信的时候，可以直接从缓存中获取到硬件地址。ARP对保存在缓存中的每一个地址映射项都设立了一个生存周期（TTL），凡是超过TTL项都会被从高速缓存中清除掉，，然后会重新广播获取最新的IP地址与MAC地址映射记录。

ARP协议解决的是**同一个局域网内的**主机或者路由器IP地址和硬件地址之间的映射关系。如果要找的目标主机和源主机不在同一个网段内，**就无法解析出另一个局域网上主机的MAC地址**。

ARP的四种经典情况

![image](https://img2020.cnblogs.com/blog/2361214/202108/2361214-20210804213653089-1203580930.png)

1. 发送方是主机（H1），要把IP数据报发送到同一个网络的另一台主机（H2），这时候H1发送一个ARP请求分组报文找到目的主机H2的MAC地址.
2. 发送主机是（H2），要把IP数据报发送到另一个网络上的主机（H3/H4），这时(H1)发送一个ARP请求分组在局域网1内广播，找到局域网1 的路由器R1的MAC地址，剩下的工作交给路由器R1来完成。R1要做的是3和4.
3. 发送方是路由器(R1),要把数据报发送给与R1连接在同一个网络上的主机（H3），这时候路由器R1会发送一个ARP请求分组在局域网2内广播，找到主机（H3）的MAC地址。
4. 发送方是路由器R1,要把IP数据包报转发到网络3上的一台主机,如（H4），由于H4主机与R1路由器不是在同一个网段内，这时候路由器R1会发送一个ARP请求分组给路由器R2，剩下的步骤由路由器R2完成。

## IP数据报的格式

1. IP数据报的格式
![image](https://img2020.cnblogs.com/blog/2361214/202108/2361214-20210804213714543-194163108.png)

在TCP/IP的标准中，各种数据格式常常是32位(8字节)，上图是完整的格式。

IP数据报是由报首和数据两部分组成。首部包括**20个字节的固定长度**和可选字段。

1. **版本** 占4位。指的是IP协议的版本。**通信双方必须要使用相同的IP协议版本**。目前广泛使用的是IP协议版本是IPV4和和IPV6
2. **首部长度** 占用4位，可以表示最大的1111（15）
3. **区分服务占用** 占8位，用来获取更好的服务，这个字段只有在使用区分服务的时候才起作用，一般情况下不使用该服务。
4. **总长度** 占用16位，指的是首部和数据之和的长度。单位为字节，总长度字段为16位，因此数据报的长度为$2^16$-1=65535字节，但在现实生活中确实很少遇到。在网络层下面的数据链路层，规定了一个数据帧中的数据字段**最大传送单元MTU**，当一个IP数据报文封装成链路层的帧的时候，此数据报的长度，一定不能超过数据链路成所规定的MTU值。最常用的以太网规定其MTU最大值为1500字节。如果传输的数据报长度超过数据链路层的MTU值，就必须把过长的数据报进行分片处理。虽然使用尽可能长的IP数据报会使得传输效率更高一些（因为内一个IP数据报中首部长度占数据报总长度的比例小一些），但数据报短些也有好处。**每一个IP数据报越短，路由器转发的速度越快。**为此，IP协议规定，在互联网中所有的主机和路由器，**必须能够接受长度不能超过576字节的数据报**，这是假定上层交下来的数据长度有**512字节（合理的长度）**，加上最长部分的IP数据报首部60字节再加上**4个字节的富余量**，就得到了576字节。当主机需要发送576字节的数据报的时候。应当需要先询问目标主机能否接受所要发送的数据报长度，否则，就要进行**分片**。
5. **标识占16位**，IP软件在存储器中维持一个计数器，每产生一个数据报，计数器就+1 ，但是这个并不是序号，因为IP是**无连接服务**,数据报不存在按序接收的问题，当数据报由于长度超过网络的MTU而必须分片的时候，这个标识的字段的值就会被复制到所有的数据报片的标识字段中，相同标识字段的值使得分片后最后能够正确的重装为原来的数据报。
6. **标志（Flag）** 占3位，只有两位有意义：

* 标志字段中的最低位为**MF(more fragment)**：当MF=1时候表示后面**还有分片**，当MF=0表示**这已经是最后一个数据报片。**
* 标志字段中的中间位**DF(don't fragment)**意思之不能再分片，只有当DF=0才允许分片。

7. **片偏移** 占13位，较长的分组在分片后，某片在原分组中的相对位置，也就是说，相对与用户数据字段的起点，该片从何时开始。**片偏移以8个字节为偏移单位**，也就是说：**每个分片的长度一定是8字节的整数倍。**
8. **生存周期TTL**：占8位，表明这是数据报在网络中的寿命，在路由器中称之为**跳数限制**。目的就是为了防止在路由器之间无限**转圈**导致白白耗费网络资源。**每经过一个路由器，TTL就-1**，当TTL=0,路由器就会丢掉这个IP数据报，一般TTL默认为**16**。
9. **协议**，占8位，协议字段指的是此数据报所携带的数据是使用的何种协议，**以便于目的主机的IP层知道应将数据部分上交给哪一个协议来处理。**

![image](https://img2020.cnblogs.com/blog/2361214/202108/2361214-20210804213730720-673752421.png)
10. **首部校验和**：占16位，这个字段只检验数据报的首部，不包括数据本身部分，这是因为数据报每经过一次路由器，路由器都会重新计算生存周期，标志，偏移量等等，不检验数据部分可以减少路由器的工作量。除此之外，为了减少校验工作量，IP数据报的首部校验和并不会使用CRC检验码，而是采用从下面简单的校验方式：
![image](https://img2020.cnblogs.com/blog/2361214/202108/2361214-20210804213744512-216496751.png)

* 在发送方，先把IP数据报首部划分为许多16位字的序列，并把检验和字段设置为**0**，用反码算数运算把所有16位字相加后，将得到的和的反码写入检验校验和中，接收方收到数据报之后，把首部的所有16位字在使用反码算相加一次，将得到的和取反码，即得到接收端检验和的计算结果。若首部未发生变化，则检验和必然为0，于是就保留这个数据报，否则认为出错，就直接丢弃。

11. **源地址** 占32位。
12. **目的地址** 占32位。
