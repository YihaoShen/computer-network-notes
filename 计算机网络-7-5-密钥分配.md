## 密钥分配

由于密码算法是公开的，网络的安全性就完全基于密钥的安全保护上。因此在密码学中出现了一个重要的分支**密钥管理**。密钥管理包括：密钥的产生、分配、注入、验证和使用。本节只讨论密钥的分配。

**密钥分配**（或**密钥分发**）是密钥管理中最大的问题。密钥必须通过最安全的通路进行分配。例如，可以派非常可靠的信使携带密钥分配给互相通信的各用户。这种方法称为**网外分配方式**。但随着用户的增多和网络流量的增大，密钥更换频繁（密钥必须定期更换才能做到可靠），派信使的办法已不再适用，而应采用**网内分配方式**，即对密钥自动分配。

### 对称密钥的分配

对称密钥存分配存在以下两个问题:
1. 如果n个人中的每一个需要和其他n－1个人通信，就需要 n(n－1)个密钥。但每两人共享一个密钥，因此密钥数是n(n - 1)/2。这常称为$n^2$问题。如果n是个很大的数，所需要的密钥数量就非常大。
2. 通信的双方怎么才能安全的共享到密钥呢?正是因为网络的不安全，所以才需要使用加密技术。但密钥又需要怎样传输呢？

目前常用的是密钥分配方式是设立**密钥分配中心KDC(Key Distribution Center)**。KDC是大家都信任的机构，其任务就是给需要进行秘密通信的用户临时分配一个会话密钥(仅使用一次)。在图7-10中假定用户A和用户B都是KDC的登记用户。A和B在KDC登记时就已经在KDC服务器上安装了各自和KDC进行通信的**主密钥(master key)**$K_A$和$K_B$。为了简单起见，下面在叙述时把主密钥简称为密钥。密钥分配为3个步骤(如图7-11):

![image](https://img2022.cnblogs.com/blog/2361214/202203/2361214-20220317123754464-1053507618.png)

1. 用户A向密钥分配中心KDC发送时用明文，说明想和用户B通信。在明文中给出A和B在KDC登记的身份。
2. KDC用随机数产生“一次一密”的会话密钥$K_{AB}$供A和B的这次会话使用，然后向A发送回答报文。这个回答报文用A的密钥$K_A$加密。这个报文中包含这次会话使用的密钥$K_{AB}$和请A转给B的一个**票据(ticket)**<该票据包括A和B在KDC登记的身份，以及这次会话将要使用的密钥$K_{AB}$。票据用B的密钥$K_B$加密，A无法知道此票据的内容，因为A没有B的密钥$K_B$，当然A也不需要知道此票据的内容。
3. 当B收到A转来的票据并使用自己的密钥$K_B$解密后，就知道A要和他通信，同时也知道KDC为这次和A通信所分配的会话密钥$K_{AB}$。

此后，A和B就可以使用会话密钥$K_{AB}$进行这次通信了。
请注意，在网络上传送密钥时，都是经过加密的。解密用的密钥都不在网络上传送。

KDC还可在报文中加入时间戳，以防止报文的截取者利用以前已记录下的报文进行重放攻击。会话密钥$K_{AB}$是一次性的，因此保密性较高。而KDC分配给用户的密钥$K_A$和$K_B$，都应定期更换，以减少攻击者破译密钥的机会。

目前最出名的密钥分配协议是Kerberos V5° [RFC 4120,4121，目前是建议标准]，是美国麻省理工学院(MIT)开发的。Kerberos既是鉴别协议，同时也是KDC，它已经变得很普及，现在是互联网建议标准。Kerberos 使用比 DES 更加安全的高级加密标准 AES 进行加密。下面用图 7-12 介绍 Kerberos V4 的大致工作过程（其原理和V5大体一样，但稍简单些）。

![image](https://img2022.cnblogs.com/blog/2361214/202203/2361214-20220317123740282-125750752.png)

1. A用明文（包括登记的身份）向鉴别服务器AS表明自己的身份。AS就是KDC，它掌握各实体登记的身份和相应的口令。AS对A的身份进行验证。只有验证结果正确，才允许A和票据授予服务器TGS进行联系。
2. 鉴别服务器AS向A发送用A的对称密钥$K_A$加密的报文，这个报文包含A和TGS通信的会话密钥$K_S$以及AS要发送给TGS的票据（这个票据是用TGS的对称密钥$K_{TG}$加密的）。A并不保存密钥$K_A$，但当这个报文到达A时，A就键入其口令。若口令正确，则该口令和适当的算法一起就能生成密钥$K_A$。这个口令随即被销毁。密钥$K_A$用来对AS发送过来的报文进行解密。这样就提取出会话密钥$K_S$（这是A和TGS通信要使用的）以及要转发给TGS的票据（这是用密钥$K_{TG}$加密的）。
3. A向TGS发送三项内容:
   1. 转发鉴别服务器AS发来的票据。
   2. 服务器B的名字，这表明A请求B的服务，请注意，现在A向TGS证明自己的身份并非通过键入口令(因为入侵者很容易的从网络上截获明文口令)，而是通过转发AS发出的票据(只有A才能提取出)。票据是加密的，入侵者伪造不了。 
   3. 用$K_S$加密的时间戳T。它用来防止入侵者的重放攻击。
4. TGS发送两个票据，每一个都包含A和B通信的会话密钥$K_{AB}$。给A的票据用$K_S$加密；给B的票据用B的密钥$K_B$加密。请注意，现在入侵者不能提取 $K_{AB}$，因为不知道$K_S$和$K_B$。入侵者也不能重放步骤3，因为入侵者不能把时间戳更换为一个新的（因为不知道$K_S$）。如果入侵者在时间戳到期之前，非常迅速地发送步骤3的报文，那么对 GS发送过来的两个票据仍然不能解密。
5. A向B转发TGS发来的票据，同时发送用$K_{AB}$加密的时间戳T。
6. B把时间戳+1来证实TGS给出的会话密钥$K_{AB}$进行通信。

顺便指出，Kerberos 要求所有使用 Kerberos 的主机必须在时钟上进行“松散的”同步。所谓“松散的”同步是要求所有主机的时钟误差不能太大，例如，不能超过5分钟的数量级。这个要求是为了防止重放攻击。TGS 发出的票据都设置较短的有效期。超过有效期的票据就作废了。因此入侵者即使截获了某个票据，也不能长期保留用来进行以后的重放攻击。

### 公钥的分配

在公钥密码体制中，如果每个用户都具有其他用户的公钥，就可实现安全通信。看起来好像可以随意公布用户的公钥，其实不然。设想用户A要欺骗用户B，A可以向B发送一份伪造是C发送的报文，A用自己的私钥进行数字签名，并附上A自己的公钥，谎称这公钥是C 的。B如何知道这个公钥不是C的呢？显然，这需要有一个值得信赖的机构来将公钥与其对应的实体（人或机器）进行绑定(binding)。这样的机构就叫做认证中心 CA(Certification Authority)，它一般由政府出资建立。每个实体都有 CA 发来的证书
(certificate)，里面有公钥及其拥有者的标识信息（人名或IP地址）。此证书被CA进行了数字签名。任何用户都可以从可信的地方获得认证中心CA的公钥，此公钥用来验证某个公钥是否为某个实体所拥有(通过向CA进行查询)。

