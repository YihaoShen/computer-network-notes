### 内部网关协议OSPF（开放最短路径优先）
出现的原因：为了克服RIP协议的缺点在1989年开发出来，**开放

**表明OSPF协议不受任何厂家的限制。**最短路径优先**是因为使用了**最短路径算法SPF**。

OSPF最主要的特征是使用分布式的**链路状态协议(link state protocol)**,而不是像RIP协议那样的距离向量协议，和RIP协议相比，OSPF的三个要点和RIP都不一样：
* 向本自治系统中的**所有路由器**发送信息。这里使用的方法是**洪范法(flooding)**，这就是路由器通过所有输出端口向相邻的路由器发送信息。而每一个相邻的路由器又再将此信息发往其所有的相邻路由器。这样，最终整个所有的路由器都得到了这个信息的一个副本。更具体的做法后面继续讨论，我们应该注意，RIP协议是仅仅向自己相邻的几个路由器发送信息。
* 发送的信息就是与本路由器**相邻的所有路由器的链路状态**，但这只是路由器所知道的**部分信息**，所谓的链路状态就是说明本路由状态都和哪些路由相邻，对于RIP协议，发送的信息是：“到所有网络的距离和下一跳路由器”。
* 只有当链路状态**发生变化**时候，路由器才能向所有路由器采用洪范法发送此信息。而不像RIP那样，不管网络拓扑结构是否发生变化，路由器之间都要定期更换路路由表信息。
  
由于各路由器之间频繁的交换链路状态信息，因此所有的路由器最终都能建立一个**链路状态数据库(link-state database)**，这个数据库的实质是**全网的拓扑结构图**，这个拓扑结构在全网就是**一致**的。因此，每一个路由器知道全网共有多少个路由器，以及那些路由器是相连的，其代价是多少等等。每一个路由器使用链路状态数据库中的数据，构造出自己的路由表(例如迪杰斯特拉的最短路径算法)。我们注意到，RIP协议的每一个路由器虽然知道所有网络的距离以及下一跳以及下一跳路由器，但**却不知道全网的拓扑结构(只有到了下一跳路由器，才能知道再下一跳怎么走)**。

OSPF的链路状态数据库能较快的进行更新，使得各路由器表能及时更新路由表。OSPF的**更新过程收敛较快**是其重要的优点。

OSPF不采用UDP而是直接使用IP数据报传送(其IP数据报的首部的协议字段是89)，OSPF构成的数据报很短，这样做能够减少路由信息的通信量。数据报很短的另一好处就是可以不必将长的数据报分片传送，分片传送的数据报只要丢一个，就无法组装成原来的数据报，而整个数据报就必须重传。

OSPF分组使用24字节的固定长度首部(图4-35)，分组的数据部分五种类型分组中的一种。

![image](https://img2020.cnblogs.com/blog/2361214/202112/2361214-20211204183044542-345494474.png)

1. **版本** 当前版本是2。
2. **类型** 五种类型分组中的一种。
3. **分组长度** 包括OSPF首部在内的分组长度，以字节为单位。
4. **路由器标识符** 标志发送该分组的路由器的接口的IP地址。
5. **区域标识符**   非组属于区域的标识符。
6. **检验和**   用来测量分组中的差错。
7. **鉴别类型** 目前只有两种，0(不用)和1(口令)。
8. **鉴别** 鉴别类型为0时就填入0，为1时则填入8个字符的口令。


除了以上的基本特点，OSPF还有下列一些特点：
1. OSPF允许管理员给每一条路由指派不同的代价，**OSPF**对于不同类型的业务计算出不同的路由，这种灵活性时RIP没有的。
2. 如果到同一个网络有多余的相同代价的路径，那么可以将通信量分配给在这几条路径，这种叫做多路径之间的**均衡负载(load balancing)**。在代价相同的多条路径上分配通信量时通信量工程的简单形式，RIP只能找出到某一个网络的一条路径。
3. 所有在OSPF路由器之间交换的分组(例如:链路状态更新分组)都具有**鉴别**的功能，因而能保证仅在可信赖的路由器之间交换交换链路状态信息。
4. OSPF支持可变长的子网划分和无分类编址CIDI。
5. 由于网络中的链路状态可能经常发生变化，因此OSPF让每一个链路状态都带上一个32位的**序号**，序号越大状态越新。OSPF规定，链路状态序号增长的速率不得超过每5秒1次，这样，全部序号空间在600年内不会产生重复号。

#### OSPF的五种分组类型

OSPF一共有以下五种分组类型：
1. **类型1，问候(Hello)**分组，用来发现和维持邻站的可达性。
2. **类型2，数据库描述(Database Description)分组**，向邻站给出自己的链路状态数据库中的所有链路状态项目的摘要信息。
3. **类型3，链路状态请求(Link State Request)分组**，向对方请求发送某些链路状态项目的详细信息。
4. **类型4，链路状态更新(Link State Update)分组**，用洪范法对全网更新链路状态。这种分组时最复杂的，也是OSPF协议最核心的部分。路由器使用这种分组将其链路状态通知给邻站。链路状态更新分组共有5种不同的链路状态。
5. **类型5，链路状态确认(Link State Acknowledgment)分组**，对链路更新分组的确认。OSPF协议规定，每两个相邻的路由器每隔10s要交换一次问候分组，这样就能确认哪些邻站是可达的。若有40s没有收到某个相邻路由器发送过来的问候分组，则可认为该相邻路由器时不可达的，应立即修改链路状态数据库，并重新计算路由表。

当一个路由器刚开始工作的时候，它只能通过**问候分组**得知它有哪些相邻的路由器在工作，以及将数据发往相邻路由器所需要的“代价”。如果所有的路由器都把自己的本地链路状态信息对全网进行广播，那么个路由器只要将这些链路状态信息综合起来就可得出链路状态数据库，但这样做开销太大，因此OSPF采用下面的方法。

OSPF让每一个路由器用数据库描述分组和相邻路由器交换本数据库中已有的链路状态摘要信息，摘要信息主要是指出了那些路由器状态信息(以及序列号)已经写入了数据库，经过与相邻路由器交换数据库描述分组后，路由器就使用链路状态请求分组，向对方请求发送自己所缺少的某些链路状态项目的详细信息。通过一系列的这种分组交换，全网同步的链路数据库就建立了，图4-36给出了OSPF的基本操作，说明了两个路由器需要交换的各种类型分组。

![image](https://img2020.cnblogs.com/blog/2361214/202112/2361214-20211204183114738-1945132598.png)

在网络运行的过程中，只要一个路由器链路状态发生变化，该路由器就要使用链路状态更新分组，用洪范法发出链路状态更新分组。OSPF使用的是**可靠的洪范算法**，其要点见图4-37所示，设路由器R用洪范法发出链路状态更新分组。图中用一些小的箭头表示更新分组。第一次先给相邻的三个路由器。这三个路由器将收到的分组再进行转发时，要将其上游路由器除外。可靠的洪范算法是在收到更新分组后要发送确认(收到的更新分组只需要发送一次确认)。图中的空心箭头表示确认分组。

![image](https://img2020.cnblogs.com/blog/2361214/202112/2361214-20211204183130973-732797519.png)

为了确保链路状态数据库与全网的状态保持一致， OSPF 还规定每隔一段时间，如 30 分钟，要刷新一次数据库中的链路状态。由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，因而与整个互联网的规模并无直接关系。因此当互联网规模很大时， OSPF 协议要比距离向量协议犯P好得多。由于 OSPF 没有“坏消息传播得慢”的问题，据统计，其响应网络变化的时间小于 100 ms 。若N个路由器连接在一个以太网上，则每个路由器要向其他(N-l)个路由器发送链路状态信息，因而共有 N(N-l)个链路状态要在这个以太网上传送。 OSPF协议对这种多点接入的局域网采用了指定的路由器(designated router)的方法，使广播的信息量大大减少。指定的路由器代表该局域网上所有的链路向连接到该网络上的各路由器发送状态信息。