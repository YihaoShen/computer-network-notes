### 数据链路层使用的信道主要有一下两种类型

### 点对点信道

这种信道使用一对一的点对点通信方式。

### 广播信道

这种信道主要是用一对多的广播通信方式。

局域网虽然是个网咯，但我们并不把局域网放到互联网上考虑。在本章中我们研究的是在同一个局域网中，分组怎样从一个主机传送到另一台主机，但并不经过路由器转发，从整个互联网上来看，局域网中仍然属于数据链路层的范围。

## 本章最主要的知识点

* 熟路链路层的点对点信道和广播信道的特点，以及这两种信道使用的协议PPP协议和CSMA/CD协议的特点
* 数据链路层的三个基本问题：封装成帧，透明传输，差错检测。
* 以太网MAC层的硬件地址
* 适配器，转发器，集线器，网桥，以太网交换机的作用以及使用场合。


我们观察一下两台主机通过互联网进行通信时**数据链路层**所处的地位  
    ![主机H1向H2发送数据](https://img2020.cnblogs.com/blog/2361214/202108/2361214-20210804012643783-310600253.png)

    ![从层次上看数据的流动](https://img2020.cnblogs.com/blog/2361214/202108/2361214-20210804012703277-1794297554.png)

图3-1（a）表示主机H1通过电话线上网，中间经过三个路由器（R1,R2,R3)连接到远程主机H2，所经过的网络是多种的，如电话网，局域网，广域网等。当主机H1向主机H2发送数据时，从协议的层次上来看，数据流动如图3-2(b)所示，主机H1和主机H2都有完整的五层协议栈，单路由器在转发分组时使用的协议栈只有下面三层。数据进入路由器后要先从物理层上到网络层，在转发表中找到下一跳地址后，再下到物理层转发出去。当我们专注于研究数据链路层的问题时，我们可以这样研究：**H1的链路层->R1的链路层->R2的链路层->R3的链路层->H2的链路层。**

## 使用点对点信道的数据链路层

### 数据链路和帧

**链路**指的是从一个结点到**相邻结点**的一段物理线路（有线或无线）,而中间并没有任何其他的交换结点。在进行数据通信时，两台计算机之间的通信路径往往要经过很多段这样的链路。可见链路只是路径的一部分。

**数据链路**：当在一条线路上传输数据时，除了必须要有一条物理线路外，还必须要有一些必要的通信协议来控制数据的传输，若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。现在最常用的就是**网络适配器(既有软件，也有硬件)**来实现这些协议。一般的适配器都包括了数据链路层和物理层这两层的功能。

点对点信道的数据链路层的协议数据单元：**帧：**

数据链路层把网络层交下来的数据构成**帧**发送到链路上，以及把接收到的帧中的数据取出并上交给网络层。在网络层中，网络层协议数据单元就是**IP数据报，也叫分组或者包**。

数据链路层通信图

![](https://img2020.cnblogs.com/blog/2361214/202108/2361214-20210804012720318-1275718965.png)

点对点信道的数据链路层在进行通信时的主要步骤如下：

1. 结点A的数据链路层把网络层交下来的IP数据报文**添加首部和尾部封装成帧**。

2. 结点A把封装好的帧发送给结点B的数据链路层。

3. 若结点B的数据链路层接收到的帧无差错则从接收到的帧**提取出IP数据报**上交给上面的网络层；否则丢弃这个帧。

## 三个基本问题:**封装成帧，透明传输，差错检测**

### 封装成帧

封装成帧是在一段数据的前后分别加上**首部**和**尾部**，这样就构成了一个帧。接收端在接收到物理层上交的**比特流**后，就能根据手部和尾部的标记，会从比特流中识别到**帧的开始**和**帧的结束**。如图就是一个添加帧首和帧尾封装成帧
![](https://img2020.cnblogs.com/blog/2361214/202108/2361214-20210804012738051-1843248787.png)

我们知道，分组交换的的一个重要概念就是：**所有在互联网上传送的数据都是以IP数据报文为传送单位，网络层的IP数据报传送到数据链路层就成为了帧的数据部分。在帧的数据部分的前部和后部分别加上首部和尾部，就构成了一个完整的帧。这样的帧就是数据链路层的数据传送单元。**

一个帧的长度等于**数据部分的长度+帧首+帧尾的长度**，首部和尾部的重要作用就是**帧定界（确定帧的界限）。**

在发送帧的时候，是从帧的首部开始送的。各种数据链路层协议都要对帧首部和帧尾部的格式都有明确的规定。为了**提高帧的传输效率，应该使帧的数据部分尽可能的大于帧的首部和尾部的长度。但是呢，每一种数据链路层协议都规定了所能传送的帧的数据部分长度上限-----最大传送单元MTU(Maximum Transfer Unit)。**如图给出了MTU与帧的数据部分和帧的首部和尾部的关系。
![用帧首部和尾部封装成帧](https://img2020.cnblogs.com/blog/2361214/202108/2361214-20210804012758619-1731798184.png)

帧首部使用**SOH（start of head）十六进制编码01**作为帧的开始控制字符，帧尾部使用**EOT（end of transmission）十六进制编码04**作为帧的结束控制字符。

### 透明传输

由于帧的开始和结束标记会用专门的控制字符，**因此，所传输的数据中的任何8比特组合一定不允许使用作为帧定界的控制字符比特编码一样，否则会出现帧定界错误。**

当传送的帧使用文本文件组成的时候(文本文件中的字符是从键盘上输入的)，其数据部分显然不会出现SOH和EOT这样的帧定界控制字符。不管在键盘上输入什么字符都可以放单帧上传输，因此这样的传输就是**透明传输。**

但是当数据部分并不是键盘上普通的ASCII码时候，而是例如像二进制代码或者图像，音乐等数据流时，情况就有可能变得不一样，如果数据中的某个字节的二进制比特刚好和帧定界符的控制字符**SOH(01)或者EOT（04）**重合，如图,数据链路层可能会错误的找到帧界定符。数据链路层会**错误的**找到帧定界符号，把部分帧接收下(误认为是个完整的帧)这样的错误传输情况显然并**不是透明传输。**

![](https://img2020.cnblogs.com/blog/2361214/202108/2361214-20210804012816711-1357973320.png)

为了解决透明传输问题，就必须设法**使数据中可能出现的控制字符SOH，EOT**在接收端不被解释为控制字符，具体的方法是：**发送端的数据链路层如果在数据传输中出现SOH或者EOT，就在前面插入一个转义字符ESC（十六进制编码为1B），而且在接收端删除这个转义字符，这样的方法称之为字节填充或者是字符填充。**，如果转义字符也出现在数据当中，那么解决办法仍然是在转义字符的前面再加上一个转义字符，因此，当接收端连续的接收到两个转义字符的时候，就删除前面其中一个。如图为用字节串书法解决透明传输问题：

![](https://img2020.cnblogs.com/blog/2361214/202108/2361214-20210804012835712-715668617.png)


### 差错检测

现实中的通信链路都是不理想的。也就是说，比特在传输的过程当中，可能1会变成0,0或者变成1，这就叫做**比特差错**，在一段时间内，传输错误的比特总数占传输所有比特总数的比值，称之为**误码率(BER)**,
误码率与信噪比有着很大的关系，如果设法提高信噪比，就可以使误码率减少。实际的通信链路并非是理想的，它不能使误码率降低到0，因此呢，在计算机网络传输数据的时候，必须采用各种校验，目前在数据链路层广泛的采用了**CRC循环冗余检验**的检错技术。下面我们通过一个简单的例子来说明CRC循环冗余检验的原理：

* 在发送端，先把数据划分为组，假设每组k个比特。先假设待传送的数据M=101001(k=6)，CRC运算就是在数据M的后面添加供差错检测使用的n为冗余码，然后构成一个帧发送出去，一共发送(k+n)位。在所要发送的数据后面增加n为的冗余码，虽然增大了数据传输的开销，但是却可以进行差错检测，当传输可能出现差错时，付出这种代价往往是很值得的。
* 这n位冗余码可以用以下方法得出：用二进制的**模2运算(二进制加法不进位)**进行2^n乘M运算，这相当于在M后面添加n个0，得到的(k+n)位的数除以收发双方事先商定的长度(n+1)位的除数p，得出商是Q余数是R(n位，比P少一位)，例如：假定除数为P=1101，经过模2除法运算后的结果是：商Q为110101，余数R为001。这个余数R就可以当作循环冗余码拼接到数据M的后面发送出去，这种为了将检错而增加的冗余码成为**帧检验序列FCS**，因此加上FCS后发送的帧为101001001(即$x^{2}$M+FCS),共有(k+n)位。

![image](https://img2020.cnblogs.com/blog/2361214/202111/2361214-20211103123556553-1746870310.png)

顺便说一下，循环冗余码CRC是一种检错方式，而FCS是添加在数据后面的冗余码。

在接收端把接收到的数据以帧为单位进行CRC检验，把收到的每一个帧都除以相同的除数P(模2运算)。
如果在传输过程中没有差错，那么经过CRC检验后得到的余数R为0，
在接收端对收到的每一帧经过CRC检验，会有以下两种情况

* 若得出余数为0，就判定这个帧没有出现差错，就**接受**。

* 若得到余数不为0，则判断这个帧有差错（但是并不知道哪里错了），丢弃

在数据链路层，发送端帧检测序列FCS的生成和接收端的CRC检验都是硬件完成的，因此处理速度很快并不会影响数据的传输。

**数据链路层不使用确认和重传机制，也就是不要求数据链路层向上册提供可靠服务，如果在数据链路层传输数据出现了错误，那么交给上层去解决，数据链路层都是不可靠的传输协议**。 
