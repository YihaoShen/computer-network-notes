## 运输层章节重要概念

* 运输层提供应用进程之间的逻辑通信，也就是说，运输层之间的通信并不是在两个运输层之间直接传递数据。运输层向应用层屏蔽了下面网络的细节（如网络拓扑、所采用的的路由选择协议等），它使应用进程看见的就是好像在两个运输层实体之间有一条端到端的逻辑通信信道。

* 网络层为主机之间提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信。

* 运输层有两个主要的协议：TCP 和 UDP。它们都有复用和分用，以及检错的功能。当运输层采用面向连接的 TCP 协议时，尽管下面的网络是不可靠的（只提供尽最大努力服务），但这种逻辑通信信道就相当于一条全双工通信的可靠信道。当运输层采用无连接的UDP协议时，这种逻辑通信信道仍然是一条不可靠信道。

* 运输层用一个 16 位端口号来标志一个端口。端口号只具有本地意义，它只是为了标志本计算机应用层中的各个进程在和运输层交互时的层间接口。在互联网的不同计算机中，相同的端口号是没有关联的。

* 两台计算机中的进程要互相通信，不仅要知道对方的 IP 地址（为了找到对方的计算机），而且还要知道对方的端口号（为了找到对方计算机中的应用进程）。

* 运输层的端口号分为服务器端使用的端口号（0 ～ 1023 指派给熟知端口，1024~49151是登记端口号）和客户端暂时使用的端口号（49152～65535）。

* UDP 的主要特点是：(1)无连接；(2) 尽最大努力交付；(3) 面向报文；(4)无拥塞控制；(5) 支持一对一、一对多、多对一和多对多的交互通信；(6) 首部开销小（只有四个字段：源端口、目的端口、长度、检验和）。

* TCP 的主要特点是：(1)面向连接；(2) 每一条 TCP 连接只能是点对点的（一对一）；(3)
  ) 提供可靠交付的服务；(4) 提供全双工通信；(5) 面向字节流。

* TCP用主机的IP地址加上主机上的端口号作为TCP 连接的端点。这样的端点就叫做套接字（socket）或插口。套接字用（IP 地址：端口号）来表示。

* 停止等待协议能够在不可靠的传输网络上实现可靠的通信。每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。分组需要进行编号。

* 超时重传是指只要超过了一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求 ARQ。

* 在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。

* 连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组都可连续发送出去，而不需要等待对方的确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已正确收到了。

* TCP 报文段首部的前 20 个字节是固定的，后面有 4N 字节是根据需要而增加的选项（N 是整数）。在一个 TCP 连接中传送的字节流中的每一个字节都按顺序编号。首部中的序号字段值则指的是本报文段所发送的数据的第一个字节的序号。

* TCP 首部中的确认号是期望收到对方下一个报文段的第一个数据字节的序号。若确认号为N，则表明：到序号 N－1为止的所有数据都已正确收到。

* TCP 首部中的窗口字段指出了现在允许对方发送的数是经常在动态变化着的。

* TCP 使用滑动窗口机制。发送窗口里面的序号表示允许发送的序号。发送窗口后沿的后面部分表示已发送且已收到了确认，而发送窗口前沿的前面部分表示不允许发送。发送窗口后沿的变化情况有两种可能，即不动（没有收到新的确认）和前移（收到了新的确认）。发送窗口前沿通常是不断向前移动的。

* 流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。

* 在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫做拥塞。拥塞控制就是防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。

* 流量控制是一个端到端的问题，是接收端抑制发送端发送数据的速率，以便使接收端来得及接收。拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。

* 为了进行拥塞控制，TCP 的发送方要维持一个拥塞窗口 cwnd 的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接收窗口中较小的一个。

* TCP 的拥塞控制采用了四种算法，即慢开始、拥塞避免、快重传和快恢复。在网络层，也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM）,以减少网络拥塞的发生。

* 运输连接有有三个阶段，即：连接建立、数据传送和连接释放。

* 主动发起 TCP 连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫做服务器。TCP 的连接建立采用三报文握手机制。服务器要确认客户的连接请求，然后客户要对服务器的确认进行确认。

* TCP 的连接释放采用四报文握手机制。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后就进入半关闭状态。当另一方也没有数据再发送时，则发送连接释放通知，对方确认后就完全关闭了 TCP 连接。

## 习题

1. 试说明运输层在协议栈中的地位和作用。运输层的通信和网络层的通信有什么重要的区别？为什么运输层是必不可少的？
   
   > 从通信和信息处理的角度来看，运输层像上面的应用层提供通信服务，它属于面向通信部分的最高层，同时也是用户功能中的最低层。当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，只有主机的协议栈才有运输层，而网络核心部分中的路由器在转发分组时都只用到下三层的功能。
   > 
   > 从网络层来说，通信的两端是两个主机。IP数据报的首部明确地标志了这两个主机的IP地址。但“两个主机之间的通信”这种说法还不够清楚。这是因为，真正进行通信的实体是在主机中的进程，是这个主机中的一个进程和另一个主机中的一个进程在交换数据（即通信）。因此严格地讲，两个主机进行通信就是两个主机中的应用进程互相通信。IP 协议虽然能把分组送到目的主机，但是这个分组还停留在主机的网络层而没有交付主机中的应用进程。从运输层的角度看，通信的真正端点并不是主机而是主机中的进程。也就是说，端到端的通信是应用进程之间的通信（见图 T-5-01）。因此，运输层是不可缺少的。
   > 
   > ![](C:\Users\sheny\AppData\Roaming\marktext\images\2022-02-10-11-04-25-image.png)
   > 
   > 所以运输层的通信和网络层的通信有很大的区别。网络层提供主机之间的逻辑通信，而运输层则提供应用进程之间的逻辑通信。
   > 运输层还有复用、分用的功能，还要对收到的报文进行差错检测。

2. 网络层提供数据报或虚电路服务对上面的运输层有何影响？
   
   > 网络层提供的两种服务的最大不同就是：数据报不提供可靠的交付，而虚电路服务则提供可靠的交付。初看起来，似乎是如果网络层提供了可靠的交付，那么运输层就可以简化一些，就不需要可靠交付了，因而可以简化一些。其实不然。事实证明，即使网络层提供了可靠的交付，那也只是主机到主机的通信是可靠的，而我们需要的进程到进程的通信仍然可能出错。因此，当必须保证可靠通信时，不管网络层提供多么可靠的服务，运输层仍然必须有可靠交付的协议。因此，互联网在网络层只提供比较简单的数据报服务（这样就使得网络层大大简化，使得网络的造价降低），而用连接在网络上的主机中的运输层来实现可靠交付。可见对于互联网的设计，网络层的服务并没有对运输层的设计产生多大的影响。

3. 当应用程序使用面向连接的 TCP 和无连接的IP 时，这种传输是面向连接的还是无连接的？
   
   > 这要在不同层次来看。在运输层是面向连接的，而在网络层则是无连接的。

4. 试画图解释运输层的复用。画图说明许多个运输用户复用到一条运输连接上，而这条运输连接又复用到IP数据报上。
   
   > 如图T-5-04：
   > 
   > ![](C:\Users\sheny\AppData\Roaming\marktext\images\2022-02-10-11-13-51-image.png)
   > 
   > 在图T-5-04中，主机H3同时与主机H1和H2进行通信。H1和H3的两个应用进程（HTTP和SMTP）进行通信，这需要使用两个TCP连接。这两个TCP连接所传送的报文段，使用下面的网络层的IP数据报传送。H2和 H3的应用进程（HTTP）进行通信，这需要使用一个TCP 连接。这个 TCP 连接所传送的报文段，也要使用下面的网络层的IP数据报来传送。在网络层所传送的 IP 数据报已看不到运输层以上的复用情况。

5. 试举例说明有些应用程序愿意采用不靠的UDP，而不愿意采用可靠的TCP。
   
   > 这可能有以下情况：
   > 
   > 首先，在互联网上传输实时数据的分组时，有可能会出现差错甚至丢失。如果利用 TCP协议对这些出错或丢失的分组进行重传，那么时延就会大大增加。因此，实时数据的传输在运输层就应采用用户数据报协议UDP，而不使用TCP协议。这就是说，对于传送实时数据，我们宁可丢失少量分组（当然不能丢失太多，否则重放的质量就太差了），也不要等待太晚到达的分组。在连续的音频或视频数据流中，很少量分组的丢失对播放效果的影响并不大（因为这是由人来进行主观评价的），因而是可以容忍的。在这种情况下，我们愿意采用不可靠的UDP，而不愿意采用可靠的TCP。
   > 
   > 其次，当网络出现拥塞时，TCP的拥塞控制就会让TCP的发送方放慢报文段的发送。可能有的应用程序就不愿意放慢其报文段的发送速度。另外，可能有的应用程序不需要 TCP 的可靠传输。在这些情况下，就宁可使用UDP来传送。

6. 接收方收到有差错的 UDP 用户数据报时应如何处理？
   
   > 简单的丢弃。

7. 如果应用程序愿意使用UDP完成可靠传输，这可能吗？请说明理由。
   
   > 这是可能的，但这要由应用层自己来完成可靠传输。例如，应用层自己使用可靠
   > 传输协议。当然，这还是需要相当大的工作量的。

8. 为什么说UDP是面向报文的，而TCP是面向字节流的？
   
   > 发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。这就是说，应用层交给 UDP 多长的报文，UDP 就照样发送，即一次发送一个报文，如教材的图 5-4 所示。在接收方的UDP，对IP层交上来的UDP用户数据报，在去除首部后就原封不动地交付上层的应用进程。也就是说，UDP一次交付一个完整的报文。因此，应用程序必须选择合适大小的报文。若报文太长，UDP把它交给IP层后，IP层在传送时可能要进行分片，这会降低IP层的效率。反之，若报文太短，UDP把它交给IP层后，会使IP数据报的首部的相对长度太大，这也降低了IP层的效率。

9. 端口的作用是什么？为什么端口划分为3种？
   
   > 端口是用来标志进程的。端口也就是协议端口号。但这种在协议栈层间的抽象的协议端口是软件端口，和路由器或交换机上的硬件端口是完全不同的概念。硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层的各种协议进程与运输实体进行层间交互的一种地址。不同的系统，具体实现端口的方法可以是不同的（取决于系统使用的操作系统）。TCP/IP的运输层用一个16位端口号来标志一个端口。但端口号只具有本地意义，它只是为了标志本计算机应用层中的各个进程在和运输层交互时的层间接口。在互联网中不同的计算机中，相同的端口号是没有关联的。
   > 
   > 两个计算机中的进程要互相通信,不仅必须知道对方的IP地址(为了找到对方的计算机）,而且还要知道对方的端口号（为了找到对方计算机中的应用进程）。
   > 
   > 端口号有三种。不同的端口类别有其特殊的用途。例如，客户端是通信的发起方，而服务器是服务的提供方。它们对端口的使用要求是不同的。这三种端口号是：
   > 
   > 1. 熟知端口号或系统端口号，数值为 0~1023。这些数值可在网址 www.iana.org查到。
   >    IANA把这些端口号指派给了TCP/IP最重要的一些应用程序，让所有的用户都知道。
   > 
   > 2. 登记端口号，数值为 1024~49151。这类端口号是为没有熟知端口号的应用程序使用
   >    的。使用这类端口号必须按照IANA规定的手续登记，以防止重复。
   >    上面两种端口号是服务器端使用的端口号。下面的一种是客户端使用的端口号。
   > 
   > 3. 短暂端口号，数值为49152~65535。这类端口号仅在客户进程运行时才动态选择，是
   >    留给客户进程选择暂时使用。

10. 试说明运输层中伪首部的作用
    
    > 所谓的“伪首部”是因为这种伪首部并不是UDP用户数据报或者TCP报文段真正的首部。只是在计算校验和的时候，临时添加在UDFP用户数据报或者TCP报文段的前面，得到一个临时的UDP用户数据报或者TCP报文段。检验和就是按照这个临时的UDP用户数据报或者TCP数据报文段来计算的。**伪首部既不向下传送也不向上递交，而仅仅是为了计算运输层的校验和。**

11. 某个应用进程使用运输层的用户数据报UDP，然后继续向下交给IP层后，又封装成IP数据报。既然都是数据报，是否可以跳过UDP而直接交给IP层？哪些功能UDP提供了但IP没有提供？
    
    > IP数据报只能找到目的主机而无法找到目的进程。如果应用进程直接把数据交给下面的 IP 层，那么在传送到对方IP层后，就只能交付目的主机，但不知道应当交付哪一个应用进程。UDP提供对应用进程的复用和分用功能，以及提供对数据部分的差错检验。这些功能IP 层没有提供。

12. 一个应用程序用UDP，到了IP层把数据报再划分为4个数据报片发送出去。结果前两个数据报片丢失，后两个到达目的站。过了一段时间应用程序重传UDP，而IP层仍然划分为4个数据报片来传送。结果这次前两个到达目的站而后两个丢失。试问：在目的站能否将这两次传输的4个数据报片组装成为完整的数据报？假定目的站第一次收到的后两个数据报片仍然保存在目的站的缓存中。
    
    > 不行。重传时，IP 数据报的标识字段会有另一个标识符。仅当标识符相同的 IP数据报片才能组装成一个IP数据报。前两个IP数据报片的标识符与后两个IP数据报片的标识符不同，因此不能组装成一个IP数据报。

13. 一个UDP用户数据报的数据字段为8192字节。在链路层要使用以太网来传送。试问应当划分几个IP数据报片？说明每一个IP数据报片的数据字段长度和为片偏移字段的值。
    
    > UDP用户数据报的长度为8192+8=8200B
    > 以太网数据字段最大长度是1500B。若IP首部为20B，则IP数据报的数据部分只能为1480B。1480x5+800=8200B,因此划分的数据报片共6个。
    > 第1个数据报片的片偏移字节为1480x0=0B     
    > 第2个数据报片的片偏移字节为1480x1=1480B
    > 第3个数据报片的片偏移字节为1480x2=2960B
    > 第4个数据报片的片偏移字节为1480x3=4440B
    > 第5个数据报片的片偏移字节为1480x4=5920B
    > 第6个数据报片的片偏移字节为1480x5=7400B
    
    将以上的片偏移字节数除以8，就可以得出片偏移字段值，因此片偏移字段值分别为：0、185、370、555、740、925.

14. 个UDP用户数据报的首部的十六进制表示是：06 32 00 45 00 1C E2 17。试求源端口、目的端口、用户数据报的总长度、数据部分长度。这个用户数据报是从客户发送给服务器还是从服务器发送给客户？使用UDP的这个服务器程
    序是什么？
    
    > 将十六进制转为二进制为：
    > 源端口号06 32(00000110 00110010)1586;
    > 目的端口号：00 45(00000000 01000101)69;
    > UDP用户数据报总长度00 1C(00000000 00011100)28字节;
    > 校验值:E2 17(11100010 00010111)(...)
    > 此UDP用户数据报是客户端发送给服务器(目的端口<1023，是熟知端口)。服务器程序是TFTP，TFTP服务器端口为69

15. 使用TCP对实时话音数据的传输有没有什么问题？使用UDP在传送数据文件时会产生什么问题？
    
    > 对实时话音数据的传输是不能使用TCP的。这是因为用TCP传输话音数据时，只要一出现差错或丢失，TCP 就要重传。这就产生了额外的时延，有时这种时延会达到很高的数值，使接收方无法容忍。在实时话音通信中，我们宁可丢掉几个分组（尽管话音质量会差一些，但仍然可以听懂），也不愿意收到太迟来到的分组，因为这样会使重放的话音质量严重恶化。虽然 UDP 不保证可靠交付，但 UDP 比 TCP 的开销要小很多。因此
    > 只要应用程序接受这样的服务质量就可以使用UDP。
    > 使用UDP传送数据文件时，如果出现了差错，UDP仅仅是少收了这个出错的报文段，并不通知发送方重传。这样就不能保证正确地传送数据。因此在传送数据文件时，我们都是采用TCP来传送的。

1?6. 在停止等待协议中，如果不使用编号是否可行？为什么？

    > 在停止等待协议中，如果不使用编号是不可行的，例如考虑下面的例子：
    A发送报文段M1，B收到后发送确认(无编号)。但这个确认很晚才传送给A。A在没有等到确认时，超时重传了M1。
    B 收到A发送的重传的M1。但B并不知道是重传的，因为报文段没有编号。B无法判断是重传的老报文段，还是新的报文段。B只能把A发送的重传的M1收下,并发送确认。但这个确认使A认为是对其发送的M2的确认，于是以为发送的两个报文段B都收到了。
    这样简单的例子可以看出，不使用编号，A以为发送的两个报文段都正确的传送到B，而实际上B收到了两个重复的报文段。可见在停止等待协议中。如果不使用编号是不可行的。

17. 在停止等待协议中，如果收到重复的报文段时不予理睬是否可行？
    
    > 不可以，如果不予理睬，则另一方会不断的重传重复的报文。

1？8. 假定在运输层使用停止等待协议。发送方在发送报文段 M0后在设定的时间内未收到确认，于是重传M0但M0又迟迟不能到达接收方。不久，发送方收到了迟到的对M0的确认，于是发送下一个报文段M1，不久就收到了对M1的确认。接着发送方发送新的报文段M0，但这个新的M0在传送过程中丢失了。正巧，一开始就滞留在网络中的M0现在到达接收方。接收方无法分辨出M0是旧的。于是收下Mo，并发送确认。显然，接收方后来收到的M0是重复的，协议失败了。试画出双方交换报文段的过程。

    > 如图T-5-18：
    
    我们可以看出，旧的M0被当作是新的M0!可见运输层不能使用停止等待协议。

19. 试证明：当用n比特进行分组的编号时，若接收窗口等于1（即只能按序接收分组），则仅在发送窗口不超过2”-1时，连续ARQ协议才能正确运行。窗口单位是分组。

20. 在连续ARQ协议中，若发送窗口等于7，则发送端在开始时可连续发送7个分组。因此，在每一分组发出后，都要置一个超时计时器。现在计算机里只有一个硬时钟。设这 7 个分组发出的时间分别为 to, t1,..., t6，且 $t_{out}$ 都一样大。试问如何实现这 7 个超时计时器（这叫软时钟法）？
    
    > 使用相对发送时间实现一个链表(如图T-5-20)

21. 假定使用连续ARQ协议，发送窗口大小是3，而序号范围是[0,15]，而传输媒体保证在接收方能够按序收到分组。在某一时刻，在接收方，下一个期望收到的序号是5。试问：
    (1) 在发送方的发送窗口中可能出现的序号组合有哪些？
    (2) 接收方已经发送出的、但仍滞留在网络中（即还未到达发送方）的确认分组，可能有哪些？说明这些确认分组是用来确认哪些序号的分组。
    
    > (1). 在接收方，下一个期望收到的序号是5，这表明到4为止的分组都已经收到，若这些确认都已到达发送方，则发送窗口最靠前，其范围是[5,7]。
    >  假定所有的确认都丢失了，发送方都没有收到这些确认，。这时，发送窗口最靠后，应该为[2,4]，因此，发送窗口可以是[2,4],[3,5],[4,6],[5,7]当中的任何一个。S
    >  (2). 接收方期望收到序号是5的分组，说明序号为2，3，4的分组都已经收到，并且发送了确认。对序号为1的分组的确认肯定被发送方收到了，否则发送方不可能发送4号分组。可见，对序号为2，3，4的分子组的确认仍然有可能滞留在网络中。这些确认是用来确认序号为2，3，4的分组的。

22. 主机A向主机B发送一个很长的文件,其长度为L字节。假定TCP使用的MSS为1460字节。
    (1) 在TCP的序号不重复使用的条件下，L的最大值为多少 
    (2) 假定使用上面计算出的文件长度，而运输层、网络层和数据链路层所用的首部开销共66字节，链路的数据率为10Mbit/s，试求这个文件所需的最短传输时间。
    
    > (1)可能的序号共$2^{32}$个。TCP的序号是数据字段的每一个字节的编号，而不是每一个报文段的编号，因此，这一小题与报文段的长度无关。这个文件长度L字节的最大值就是可能的序号数。
    >  (2) $2^{32}/1460=2941758.422$，需要发送2941759个帧。帧首部的开销是66×2941759=194156094字节。
    > 发送的总字节数是=232+194156094=4489123390字节。数据率10Mbit/s=1.25 MB/s=1250000字节/秒。发送4489123390字节需时间为：4489123390/1250000=3591.3秒。即59.85分，约1小时。

23. 主机A向主机B连续发送两个TCP报文段，其序号分别是70和100。试问：
    (1)第一个报文段携带了多少字节的数据
    (2)主机B收到第一个报文段后，发回的确认中的确认号是多少?
    (3)如果主机B收到第二个报文段后，发回的确认中的确认号是180，试问A发送的第二个报文段中数据有多少字节？
    (4)如果A发送的第一个报文段丢失了，但第二个报文段到达了 B。B在第二个报文段到达后向 A 发送确认。试问这个确认号应为多少？
    
    > (1)第一个报文段的数据序号是 70 到 99，共 30 字节的数据
    >  (2)B期望收到下一个报文段的第一个数据字节的序号是 100，因此确认号应为100。
    >  (3))A发送的第二个报文段中的数据中的字节数是 180-100=80字节。
    >  (4)B在第二个报文段到达后向A发送确认，其确认号应为70

24. 一个TCP连接下面使用256 kbit/s的链路，其端到端时延为 128 ms。经测试，发现吞吐量只有 120 kbit/s。试问发送窗 W是多少？（提示：可以有两种答
    案，取决于接收端发出确认的时机。）
    
    > 设发送窗口=W(bit),发送端连续发送完窗口内的数> 据为T，有两种情况：
    > 
    > 1. 接收端在收完一批数据后的最后才发出确认，因此发送端经过(256ms+T)后才能发送下一个窗口的数据。
    > 
    > 2. 接收端每收到一个很小的报文段后就发回确认，因此发送端经过256ms略多一些的时间即可再发送数据。因此每经过256ms就能发送一个窗口的数据。
    > 
    > 如图T-5-24给出了两种不同情况的图解：
    > 

25. 为什么在TCP首部中要把TCP端口号放入最开始的4个字节中？
    
    > 在ICMP差错报文中要包含IP首部后面的8个字节的内容，而这里有TCP首部中源端口和目的端口。当TCP收到ICMP差错报文时，需要用这两个端口来确定是哪条连接出现了差错。

26. 为什么TCP首部中有一个首部长度字段，而UDP没有？
    
    > TCP除了固定的首部长度外，还有一些选项，因此TCP首部长度是可变的。UDP首部长度是固定的，因此并不需要该字段。

27. 一个 TCP 报文段的数据部分最多为多少个字节？为什么？如果用户要传送的数据的字节长度，超过 TCP 报文段中的序号字段可能编出的最大序号，问还能否用TCP来传送？
    
    > 一个TCP最大报文的数据部分最多为65495字节。数据部分再加上TCP首部的20字节，再加上IP首部20字节，刚好是IP数据报的最大长度65535字节。当然，若IP首部包含了选项，则IP首部长度就超过了20字节，这时候TCP数据部分的最大长度就小于65495字节。
    > 
    > 如果用户要传送的数据的字节长度超过 TCP 报文段中的序号字段可能编出的最大序号，仍可用TCP来传送。编号用完后再重复使用。但应设法保证不出现编号的混乱。

28. 主机A向主机B发送TCP报文段，首部中的源端口是m而目的端口是n。当B向A发送回信时,其TCP报文段的首部中的源端口和目的端口分别是什么？
    
    > 解答：当B向A发送回信时，其TCP 报文段首部中的源端口就是A发送的TCP报文段首部中的目的端口 n，而B发送的TCP报文段首部中的目的端口就是A发送TCP报文段首部中的源端口 m。

29. 在使用 TCP 传送数据时，如果有一个确认报文段丢失了，也不一定会引起与该确认报文段对应的数据的重传。试说明理由。
    
    > 还未重就接收到了对更高序号的确认。

30. 设 TCP 使用的最大窗口为 65535 字节，而传输信道不产生差错，带宽也不受限制。若报文段的平均往返时间为20 ms，问所能得到的最大吞吐量是多少？
    
    > 在发送时延忽略的条件下，每20ms就可以发送65535x8=524280bit
    > 
    > 最大数据率=(524280bit)/(20ms)=26.2Mbit/s




